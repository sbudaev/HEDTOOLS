#-------------------------------------------------------------------------------
# SVN version info:
# $Id$
#-------------------------------------------------------------------------------
# Build model automatically generating include files for PRNG and IEEE
# author Sergey Budaev <sbudaev@gmail.com>
#-------------------------------------------------------------------------------

# Supported Fortran compiler types
GF_FC = gfortran
IF_FC = ifort
SF_FC = f95

# Choose the default compiler type
FC = $(GF_FC)

# Root of the host name to run in HPC cluster / batch mode, not directly
HOST_HPC_ROOT=fimm

#*******************************************************************************
# Main building blocks, define the main program source, executable name (-o)
# and possible module (.mod) names.

# These names should be set for particular project,
# Most probably they should be edited manually for each specific project
# SRC is the name of the main source code (can be several files). Note that
#   Intel fortran doesn't like f95 file extension, use f90
# OUT is the executable file

SRC = HEDG2_01.f90
OUT = HEDG2_01.exe

# These names are normally generated by the compiler. OBJ is the name of
# the object file produced by the compiler and may probably be left as is
# MOD is the modules generated by the main program, must be set manually.
# MOD is not used for anything very important, only in cleaning temporary
# files, so can be set to .mod files remaining after make clean/distclean

OBJ = $(basename $(SRC)).o
MOD = mod_ga.mod

#*******************************************************************************
# HEDTOOLS sources, object files and module files

HEDTOOLS = BASE_UTILS.f90 BASE_CSV_IO.f90 BASE_LOGGER.f90 BASE_RANDOM.f90 \
           BASE_ERRORS.f90 BASE_STRINGS.f90

HTOOLOBJ = BASE_UTILS.o BASE_CSV_IO.o BASE_LOGGER.o BASE_RANDOM.o BASE_ERRORS.o \
           BASE_STRINGS.o

HTOOLMOD = base_utils.mod  csv_io.mod  logger.mod base_random.mod \
           assert.mod errors.mod exception.mod throwable.mod precision_str.mod \
           strings.mod

# Path to HEDTOOLS and IEEE non-intrinsic libs
HEDTOOLSDIR = ../HEDTOOLS
IEEEPATH = $(HEDTOOLSDIR)/IEEE

#*******************************************************************************
# Define compiler options

# Options for GNU Fortran
GF_STATIC = -static-libgfortran -static -static-libgcc
GF_TRAPS = -ffpe-trap=
GF_RCHECKS = -Wall -fbounds-check
#GF_FFLAGS = $(GF_STATIC) $(GF_TRAPS) $(GF_RCHECKS) -O3
GF_FFLAGS = -O3 -funroll-loops -fforce-addr
#-ffpe-trap=zero,invalid,overflow,underflow
# GC_FFLAGS are for gcc C compiler (C may be used for IEEEs)
GC_FFLAGS = -O3
# On Windows might need  -mwindows

# Options for Intel Fortran
IF_STATIC = -static
IF_TRAPS =-fpe3
IF_RCHECKS = -warn -check bounds,pointers,format,uninit
IF_FFLAGS = -sox -parallel -O3 –ipo
#IF_FFLAGS = -sox -fast -parallel $(IF_STATIC) $(IF_TRAPS)
# -fpe3 no traps; -fpe0 all traps
# -O3
# Aggressive optimizations: -fast = -O3 –ipo –static

# Options for Sun/Oracle Solaris Studio
SF_STATIC = –Bstatic –dn
SF_TRAPS = -ftrap=%none
SF_RCHECKS = –C
SF_FFLAGS = -fast -autopar -depend=yes
# -fast = O5
# -ftrap=common is a macro for -ftrap=invalid,overflow,division.
# -ftrap=%all, %none, common

#-------------------------------------------------------------------------------

# DEBUG turns off all optimisations and keeps debug symbols.
ifdef DEBUG
	GF_FFLAGS = -O0 -g -ffpe-trap=zero,invalid,overflow,underflow $(GF_RCHECKS)
	IF_FFLAGS = -O0 -g -fpe0 $(IF_RCHECKS)
	SF_FFLAGS = -O0 -g -ftrap=common
endif

#-------------------------------------------------------------------------------
# Set other build options depending on the specific compiler

ifeq ($(FC),gfortran)
	FFLAGS = $(GF_FFLAGS)
	STATIC = $(GF_STATIC)
	TRAPS = $(GF_TRAPS)
	RCHECKS = $(GF_RCHECKS)
	CC=gcc
endif

ifeq ($(FC),ifort)
	FFLAGS = $(IF_FFLAGS)
	STATIC = $(IF_STATIC)
	TRAPS = $(IF_TRAPS)
	RCHECKS = $(IF_RCHECKS)
endif

ifeq ($(FC),f95)
	FFLAGS = $(SF_FFLAGS)
	STATIC = $(SF_STATIC)
	TRAPS = $(SF_TRAPS)
	RCHECKS = $(SF_RCHECKS)
endif

#*******************************************************************************
# Generate the list of modules used in the source.
# TODO: check which modules are really used in the source and compile only them

# NOTE: Make turns $$ into $ in awk call, otherwise it goes empty
#MOD_LIST=$(shell grep -i "^ *use " $(SRC) | sed -e 's/,//g' | awk '{printf(" %s ",$2) }' )
MOD_LIST=$(shell grep -i "^ *use " $(SRC) | sed -e 's/,//g' | awk '{printf(" %s ",$$2) }' )

#*******************************************************************************
# Autogenerated include file setting compiler/platform specific code for PRNG
# The module BASE_RANDOM includes some non-portable header code that
# depends on the conmpiler type. It is autogenerated here. The Fortran Module
# code contains INCLUDE statement. The appropriate include file is then
# autogenerated during the build process.
# The strategy of the build is two-step:
#    (1) Provide comment macro for the include file as well as the code adapted
#        for the specific compiler type and platform
#    (2) Select macro from the above list specific for the
#        compiler type
#    (3) build the BASE_RANDOM.o, the first statement is the include
#        autogeneration macro, then follow the compile instructions.

#  Header file setting compiler/platform specific code for PRNG module
AUTOGEN_HEADER_RAND = $(HEDTOOLSDIR)/BASE_RANDOM.inc

# Autogenerated include files
define AUTOGEN_COMMENT_RANDOM
	$(shell echo "!+---------------------------------------------------------+" > $(AUTOGEN_HEADER_RAND))
	$(shell echo "!| WARNING: auto-generated file, do NOT edit               |" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "!| Sets compiler-specific code for random number generator |" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "!+---------------------------------------------------------+" >> $(AUTOGEN_HEADER_RAND))
endef

# Include file code for GNU
define AUTOGEN_CODE_GF
	$(shell echo "! GNU Fortran compiler:" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "use ISO_FORTRAN_ENV, only: int64" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "implicit none" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "integer, allocatable :: seed(:)" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "integer :: i, n, un, istat, dt(8), pid" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "integer(int64) :: t">> $(AUTOGEN_HEADER_RAND))
endef

# Include file code for Intel
define AUTOGEN_CODE_IF
	$(shell echo "! Intel Fortran compiler:" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "use ISO_FORTRAN_ENV, only: int64 " >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "use IFPORT, only : getpid" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "implicit none" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "integer, allocatable :: seed(:)" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "integer :: i, n, un, istat, dt(8), pid" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "integer(int64) :: t" >> $(AUTOGEN_HEADER_RAND))
endef

# Include file code for Oracle
define AUTOGEN_CODE_SF
	$(shell echo "! Intel Oracle compiler:" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "implicit none" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "integer, allocatable :: seed(:)" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "integer :: i, n, un, istat, dt(8), pid" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "integer, parameter :: int64 = selected_int_kind(18)" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "integer(int64) :: t" >> $(AUTOGEN_HEADER_RAND))
	$(shell echo "include \"system.inc\"" >> $(AUTOGEN_HEADER_RAND))
endef

# Select autogeneration of include file for the specific compiler type
ifeq ($(FC),$(GF_FC))
	AUTOGEN_CODE_RANDOM=$(AUTOGEN_CODE_GF)
endif

ifeq ($(FC),$(IF_FC))
	AUTOGEN_CODE_RANDOM=$(AUTOGEN_CODE_IF)
endif

ifeq ($(FC),$(SF_FC))
	AUTOGEN_CODE_RANDOM=$(AUTOGEN_CODE_SF)
endif

#*******************************************************************************
# Determine compiler versions, we may need GCC version > 5 to use
# non-intrinsic IEEE math modules for gfortran < 5, GCC > 5 fully
# supports intrinsic IEEE math.
# IEEE should work with recent versions

# Check GCC version and need for non-intrinsic modules
GFORTVERSION = $(shell $(GF_FC) -dumpversion)
GFORT_LESS_5 = $(shell expr `echo $(GFORTVERSION) | cut -d. -f1` \< 5)
ifeq ($(GFORT_LESS_5),1)
	COMPILE_NONINTRINSIC_IEEE=YES
else
	COMPILE_NONINTRINSIC_IEEE=NO
endif

# IEEE non-intrinsic modules, list of sources
IEEE_NON_INTRINSIC_SRC = precision_m.f90 IEEE_FEATURES.f90 IEEE_EXCEPTIONS.f90 \
                        IEEE_ARITHMETIC.f90 c_control.c

IEEEMOD = ieee_arithmetic.mod  ieee_exceptions.mod  ieee_features.mod  \
          precision.mod

# IEEE non-intrinsic objects
IEEEOBJ = precision_m.o c_control.o IEEE_FEATURES.o IEEE_EXCEPTIONS.o \
          IEEE_ARITHMETIC.o

# Macros to auto-generate F90 headers for IEEE modules -- AUTOGEN_HEADER_FILE
AUTOGEN_HEADER_IEEE = IEEE_wrap.inc

# Check if the source does include IEEE calls at all, disable non-intrinsic IEEE
# if the Fortran source does never refer to them
IEEE_GREPPED_SRC = $(shell grep -ci $(AUTOGEN_HEADER_IEEE) $(SRC))
ifeq ($(IEEE_GREPPED_SRC),0)
	COMPILE_NONINTRINSIC_IEEE=NO
endif

ifneq ($(FC),gfortran)
	COMPILE_NONINTRINSIC_IEEE=NO
endif

# Autogenerated include files
define AUTOGEN_COMMENT_HEADER_F90
	$(shell echo "!+-----------------------------------------------------+" > $(AUTOGEN_HEADER_IEEE))
	$(shell echo "!| WARNING: auto-generated file, do NOT edit           |" >> $(AUTOGEN_HEADER_IEEE))
	$(shell echo "!| Calls intrinsic or non-intrinsic IEEE math modules  |" >> $(AUTOGEN_HEADER_IEEE))
	$(shell echo "!+-----------------------------------------------------+" >> $(AUTOGEN_HEADER_IEEE))
endef

# Now only use IEEE_EXCEPTIONS are managed. Other modules may be added:
#  IEEE_FEATURES IEEE_ARITHMETIC IEEE_EXCEPTIONS
define AUTOGEN_INTRINSIC
	$(AUTOGEN_COMMENT_HEADER_F90)
	$(shell echo "use, intrinsic :: IEEE_EXCEPTIONS" >> $(AUTOGEN_HEADER_IEEE))
endef

# Now only use IEEE_EXCEPTIONS are managed. Other modules may be added:
#  IEEE_FEATURES IEEE_ARITHMETIC IEEE_EXCEPTIONS
define AUTOGEN_NON_INTRINSIC
	$(AUTOGEN_COMMENT_HEADER_F90)
	$(shell echo "use, non_intrinsic :: IEEE_EXCEPTIONS" >> $(AUTOGEN_HEADER_IEEE))
endef

#-------------------------------------------------------------------------------

# Determine this makefile's path. Be sure to place this BEFORE `include`s
THIS_FILE := $(lastword $(MAKEFILE_LIST))

# This is the search paths for looking for components, separated by blanks
VPATH = $(HEDTOOLSDIR) $(IEEEPATH)

# Determine build platform
PLATFORM = $(shell uname)
IS_WINDOWS = $(shell uname | grep -ci windows)

# Determine if we are running on HPC cluster
RUNHOST_HPC = $(shell hostname | grep -c $(HOST_HPC_ROOT))

# Determine current SVN version of the code
SVN_VER = $(shell svn info | grep Revision: | cut -d " " -f 2)

#*******************************************************************************
# targets follow
#*******************************************************************************

# Default build target = executable
all: exec

zzz:
	@echo $(MOD_LIST)

# Short help on the options
help:
	@echo ""
	@echo ------------------------------------------------------------------------
	@echo "Building model $(SRC) ------ via $(THIS_FILE)"
	@echo ------------------------------------------------------------------------
	@echo "Normal build: make (uses $(FC) by default)"
	@echo ""
	@echo "Main (re)build (for different compiler type targets):"
	@echo "    make gnu, make intel, make sun"
	@echo ""
	@echo "Compile HEDTOOLS modelling tools: make hedtools"
	@echo ""
	@echo "Produce system-specific include headers (PRNG and IEEE): make inc"
	@echo ""
	@echo "Produce debug symbols: define DEBUG, e.g.: make DEBUG=1"
	@echo ""
	@echo "Run model: make run (make run_local for local run)"
	@echo ""
	@echo "Cleaning:"
	@echo "    make clean, make cleandata (model data only),"
	@echo "    make distclean (everything, leaving zero state!)"
	@echo ------------------------------------------------------------------------
	@echo "NOTES:"
	@echo " IEEE non-intrinsic modules: make ieee, needed only for GCC<5"
	@echo ------------------------------------------------------------------------
	@echo PROJECT: Rev: $(SVN_VER), $(PLATFORM), HPC \($(HOST_HPC_ROOT)\) $(RUNHOST_HPC)
	@echo Source: $(SRC) -- $(OUT) -- $(OBJ)
	@echo ------------------------------------------------------------------------

# shortcut to build for GNU Fortran
gnu:
	@$(MAKE) -f $(THIS_FILE) FC=gfortran

# shortcut to build for Intel Fortran
intel:
	@$(MAKE) -f $(THIS_FILE) FC=ifort

# shortcut to build for Solaris Studio Fortran
sun:
	@$(MAKE) -f $(THIS_FILE) FC=f95

# Run through PBS job script on HPC, check if we are on cluster RUNHOST_HPC
run: $(OUT) $(JOB) $(SRC)
ifeq ($(RUNHOST_HPC),1)
	qsub $(JOB)
	@echo "NOTE: fimm job created"
	@echo "Batch commands:"
	@echo "  showq -u USER = show user's jobs'"
	@echo "  qstat = display all jobs"
	@echo "  qdel jobid = delete job"
	@echo "  qhold = pause job"
	@echo "  qrls = resume job"
	@echo "https://docs.hpc.uib.no/wiki/Job_execution_(Fimm)"
else
	@$(MAKE) -f $(THIS_FILE) run_local
endif

# Note -- this is local start/run on all supported systems
run_local: $(OUT) $(SRC)
	./$(OUT)

# Main build the executable
exec: $(OUT)

# Produce include file for PRNG module
inc: $(AUTOGEN_HEADER_RAND) $(AUTOGEN_HEADER_IEEE)

# Compile the HEDTOOLS modelling tools
headtools: $(HTOOLOBJ)

# Cleanup data files, quotes needed on Windows if file starts from blank
cleandata:
	rm -f -r HED*.txt ?HED*.txt HED18*.log behaviour gene*
	rm -f -r *.csv
ifeq ($(IS_WINDOWS),1)
	rm -f -r "?HED*.txt" "HED*.txt"
endif

# Return to default state
distclean: clean
	-rm -f $(AUTOGEN_HEADER_RAND) $(AUTOGEN_HEADER_IEEE) $(HTOOLOBJ) $(HTOOLMOD) \
					$(IEEEOBJ) $(IEEEMOD)

# Clean obj etc for new build, but we don't clean HEDTOOLS' .mod files
clean: neat
	-rm -f $(OBJ) $(OUT) $(MOD)

# Cean temporary files and conflict that remain from syncthing synchronisation.
neat:
	-rm -f $(TMPFILES) *conflict*

#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# Automatic build follows, usually there is no need to edit the code below...

$(OUT): $(OBJ) $(HTOOLOBJ)
	@$(MAKE) -f $(THIS_FILE) inc
ifeq ($(COMPILE_NONINTRINSIC_IEEE),YES)
	$(FC) $(FFLAGS) -o $(OUT) $^  $(IEEEOBJ)
else
	$(FC) $(FFLAGS) -o $(OUT) $^
endif

$(OBJ): $(SRC) $(HTOOLOBJ)
ifeq ($(COMPILE_NONINTRINSIC_IEEE),YES)
	@$(MAKE) -f $(THIS_FILE) ieee_need
else
	@$(MAKE) -f $(THIS_FILE) ieee_not_need
endif
	$(FC) $(FFLAGS) -c $^

#-------------------------------------------------------------------------------
# Build HEDTOOLS

# Produce tweaked include file for PRNG
$(AUTOGEN_HEADER_RAND): $(BASE_RANDOM.f90) $(THIS_FILE)
	$(AUTOGEN_COMMENT_RANDOM)
	$(AUTOGEN_CODE_RANDOM)
	@echo Generated include: $(AUTOGEN_HEADER_RAND) for $(FC)

# compile HEDTOOLS modules
BASE_UTILS.o: BASE_UTILS.f90
	$(FC) $(FFLAGS) -c $<
BASE_CSV_IO.o: BASE_CSV_IO.f90
	$(FC) $(FFLAGS) -c $<
BASE_LOGGER.o: BASE_LOGGER.f90
	$(FC) $(FFLAGS) -c $<
BASE_RANDOM.o: BASE_RANDOM.f90 $(THIS_FILE)
	@$(MAKE) -f $(THIS_FILE) inc
	$(FC) $(FFLAGS) -c $<
BASE_ERRORS.o: BASE_ERRORS.f90
	$(FC) $(FFLAGS) -c $<
BASE_STRINGS.o: BASE_STRINGS.f90
	$(FC) $(FFLAGS) -c $<

#-------------------------------------------------------------------------------
# Build IEEE non-intrinsic modules for GNU Fortran if needed

# Generate IEEE include file
$(AUTOGEN_HEADER_IEEE): $(THIS_FILE)
ifeq ($(COMPILE_NONINTRINSIC_IEEE),YES)
	$(AUTOGEN_NON_INTRINSIC)
	@echo Generated include: $(AUTOGEN_HEADER_IEEE) for $(FC) v. $(GFORTVERSION)
else
	$(AUTOGEN_INTRINSIC)
	@echo Generated include: $(AUTOGEN_HEADER_IEEE) for $(FC)
endif

#-------------------------------------------------------------------------------
# Compile all IEEE non-intrinsic math modules if needed
ieee:
ifeq ($(COMPILE_NONINTRINSIC_IEEE),YES)
	@$(MAKE) -f $(THIS_FILE) ieee_need
else
	@$(MAKE) -f $(THIS_FILE) ieee_not_need
endif

# just issue note that we do not need IEEEs
ieee_not_need:
	@echo ------------------------------------------------------------------------
	@echo We do not need non-intrinsic IEEE modules: $(FC), grep test $(IEEE_GREPPED_SRC)
	@echo ------------------------------------------------------------------------

# build IEEEs assuming we do need them (GNU)
ieee_need: $(IEEEOBJ)
	@echo ------------------------------------------------------------------------
	@echo GNU Fortran version: $(GFORTVERSION). We NEED NON-INTRINSIC IEEE MODULES.
	@echo ------------------------------------------------------------------------

# specific components of IEEE modules are below
precision_m.o: precision_m.f90
	$(FC) -c $(FFLAGS) $<
c_control.o: c_control.c
	$(CC) -c $(GC_FFLAGS) $<
IEEE_FEATURES.o: IEEE_FEATURES.f90
	$(FC) -c -fno-range-check $(FFLAGS) $<
IEEE_EXCEPTIONS.o: IEEE_EXCEPTIONS.f90
	$(FC) -c -fno-range-check $(FFLAGS) $<
IEEE_ARITHMETIC.o: IEEE_ARITHMETIC.f90
	$(FC) -c -fno-range-check $(FFLAGS) $<
