Modelling tools manual
======================
Sergey Budaev <sbudaev@gmail.com>
v.1.0, Last updated 09/02/2016

////////////////////////////////////////////////////////
Note: asciidoc document, Generate pdf book with
a2x -fpdf BASE_UTILS.adoc
////////////////////////////////////////////////////////

:language: fortran

Abstract
--------

This document describes the modelling tools used for the new model environment.

:numbered:

Introduction
------------

These modelling tools include two separate modules: *BASE_UTILS* and *CSV_IO*.
BASE_UTILS contains a few utility functions. CSV_IO is for output of numerical
data into the CSV (comma separated values) format files. CSV is good because it
is human-readable but can still be easily imported into spreadsheets and stats
packages.

Invoking the modules requires the _use_ keyword in Fortran. _use_'s' should
normally be the first statements before _implicit none_:


[source]
--------------------------------------------------------------------------------
program TEST

  use BASE_UTILS  ! Invoke the modules
  use CSV_IO      ! into this program

  implicit none

  character (len=255) :: REC
  integer :: i
  real, dimension(6) :: RARR = [0.1,0.2,0.3,0.4,0.5,0.6]
  character (len=4), dimension(6) :: STARR=["a1","a2","a3","a4","a5","a6"]
..........
end program TEST
--------------------------------------------------------------------------------

Building the program with these modules using the command line is notmally a
two-step process:

build the modules, e.g.

[source,bash]
--------------------------------------------------------------------------------
gfortran -g -c ../BASE_CSV_IO.f90 ../BASE_UTILS.f90
--------------------------------------------------------------------------------

This step should only be done if the source code of the modules change, i.e.
quite rarely.

build the program (e.g. TEST.f90) with these modules

[source,bash]
--------------------------------------------------------------------------------
gfortran -g -o TEST.exe TEST.f90 ../BASE_UTILS.f90 ../BASE_CSV_IO.f90
--------------------------------------------------------------------------------

or for a generic F95 compiler:

[source,bash]
--------------------------------------------------------------------------------
f95 -g -c ../BASE_CSV_IO.f90 ../BASE_UTILS.f90
f95 -g -o TEST.exe TEST.f90 ../BASE_UTILS.f90 ../BASE_CSV_IO.f90
--------------------------------------------------------------------------------

NOTE: The examples above assume that the module code is located in the
upper-level directory, so "../"

Module: BASE_UTILS
------------------

This module contains a few utility functions and subroutines. So far there are
two useful things here: STDOUT, STDERR, TOSTR and CLEANUP.

Subroutines: STDOUT and STDERR
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

These subroutines output arbitrary text to the terminal, either to the standard
output and standard error. While it seems trivial (standard Fortran print *, or
write() can be used), it is still good to have a dedicated standard subroutine
for all outputs as we can then easily modify the code to use Matlab/R API to
work with and run models from within these environments, or use a GUI window
(the least necessary feature now, but may be useful if the environment is used
for teaching in future). In such cases we will then implement a specific
dedicated output function and just globally swap STDOUT with R_MESSAGE_PRINT or
X_TXTGUI_PRINT.

*STDOUT/STDERR* accept an arbitrary number of string parameters, which just
represent messages placed to the output. Each parameter is printed on a new
line. Trivial indeed:)

NOTE: It is useful to have two separate subroutines for stdout and stderr as
they could be easily separated (e.g. redirected to different files). Redirection
could be done under Windows DOS prompt in such a simple way:
model_command 1 > output_file_stdout 2 > output_file_stderr
STDOUT is redirected to output_file_stdout, STDERR, to output_file_stderr

*Examples*

[source]
--------------------------------------------------------------------------------
call STDOUT("---------------------------------------------------",&
            ch01 // " = " // ch02 // TOSTR(inumber) // " ***", &
            ch10 // "; TEST NR= " // TOSTR(120.345), &
            "Pi equals to = " //  TOSTR(realPi, "(f4.2)"), &
            "---------------------------------------------------")
--------------------------------------------------------------------------------

The above code just prints a message. Note that TOSTR function is used to append
numerical values to the text output (unlike standard write where values are
separated by commas).

Function: TOSTR
~~~~~~~~~~~~~~~

*TOSTR* converts a number to a strings. Accepts any numeric or non-numeric type,
including integer and real (kind 4 and 8), logical and strings. Also accepts
arrays of these numeric types. Outputs just the string representation of the
number. Aliases: STR (same as TOSTR), NUMTOSTR (accepts only numeric input
parameter, not logical or string)

indexterm:[TOSTR,STR,NUMTOSTR]

*Basic Examples:*

Integer:

[source]
--------------------------------------------------------------------------------
print *, TOSTR(12)
produces string "12"
--------------------------------------------------------------------------------

Single precision real (type 4)footnote:[Note that float point calculations,
especially single precision (real type 4) may introduce a rounding error]

[source]
--------------------------------------------------------------------------------
print *, ">>", TOSTR(3.1415926), "<<"
produces >>3.14159250<<
--------------------------------------------------------------------------------

Double precision real (type 8)

[source]
--------------------------------------------------------------------------------
print *, ">>", TOSTR(3.1415926_8), "<<"
produces >>3.1415926000000001<<
--------------------------------------------------------------------------------

TOSTR also converts logical type to the "TRUE" or "FALSE" strings and can also
accept character string as input. In the latest case it just output the input.

*Optional parameters*

TOSTR can also accept standard Fortran format string as the second optional
*string* parameter, for example:

[source]
print *, ">>", TOSTR(3.1415926,"(f4.2)"), "<<"
produces >>3.14<<

[source]
print *, ">>", TOSTR(12,"(i4)"), "<<"
produces >>  12<<

With integers, TOSTR can also generate leading zeros, which is useful for
auto-generating file names or variable names. In such cases, the number of
leading zeros is determined by the second optional *integer* parameter. This
integer sets the template for the leading zeros, the maximum string. The
exact value is unimportant, only the number of digits is used.

For example,

[source]
print *, ">>", TOSTR(10, 100), "<<"
produces >>010<<

[source]
print *, ">>", TOSTR(10, 999), "<<"
also produces >>010<<

[source]
print *, "File_" // TOSTR(10, 10000) // ".txt"
produces File_00010.txt

*Examples of arrays*

It is possible to convert numeric arrays to their string representation.

[source]
--------------------------------------------------------------------------------
real, dimension(6) :: RARR = [0.1,0.2,0.3,0.4,0.5,0.6]
.....
print *, ">>", TOSTR(RARR), "<<"
produces > 0.100000001 0.200000003 0.300000012 0.400000006 0.500000000 0.600000024<<
--------------------------------------------------------------------------------

[source]
--------------------------------------------------------------------------------
real, dimension(6) :: RARR = [0.1,0.2,0.3,0.4,0.5,0.6]
.....
print *, ">>", TOSTR(RARR,"(f4.2)"), "<<"
produces >> 0.10 0.20 0.30 0.40 0.50 0.60<<
--------------------------------------------------------------------------------

It is possible to use array slices and array constructors:

[source]
--------------------------------------------------------------------------------
print *, ">>", TOSTR(RARR(1:4)), "<<"
print *, ">>", TOSTR( (/(RARR(i), i=1,4)/) ), "<<"
both produce >> 0.100000001 0.200000003 0.300000012 0.400000006<<
--------------------------------------------------------------------------------

or using the newer format with square brackets:

[source]
--------------------------------------------------------------------------------
print *, ">>", TOSTR( [(RARR(i), i=1,4), 200.1, 400.5] ), "<<"
produces >> 0.100000001 0.200000003 0.300000012 0.400000006 200.100006 400.500000<<
--------------------------------------------------------------------------------

the same with format:

[source]
--------------------------------------------------------------------------------
print *, ">>", TOSTR( [(RARR(i), i=1,4), 200.1, 400.5], "(f9.3)" ), "<<"
produces >> 0.100 0.200 0.300 0.400 200.100 400.500<<
--------------------------------------------------------------------------------

Function: CLEANUP
~~~~~~~~~~~~~~~~~

*CLEANUP* Removes all spaces, tabs, and control characters from the input string.

Example:

[source]
--------------------------------------------------------------------------------
print *, ">>", CLEANUP("This is along string blablabla"), "<<"
both produce >>Thisisalongstringblablabla<<
--------------------------------------------------------------------------------

Module: CSV_IO
--------------

This module contains subroutines and functions for outputting numerical data to
the CSV (Comma separated values) format.
