Modelling tools manual
======================
Sergey Budaev <sbudaev@gmail.com>
$Id$

////////////////////////////////////////////////////////////////////////////////
Note: asciidoc document, Generate pdf book with
a2x -fpdf BASE_UTILS.adoc
manual on asciidoc is available at: http://asciidoc.org/userguide.html
////////////////////////////////////////////////////////////////////////////////

:description: Modelling tools/coding style for the new AHA! environment.

:language: fortran

Abstract
--------

This document describes the modelling tools used for the new model environment.
It is partly autogenerated. Autogeneration is incomplete at this time as most
of the model components (actual for {docdate}).

////////////////////////////////////////////////////////////////////////////////
Note: SVN tags need property setup:
svn propset svn:keywords "Id Date Revision HeadURL LastChangedDate" BASE_UTILS.adoc
svn commit BASE_UTILS.adoc -m 'set keywords for svn tags""
////////////////////////////////////////////////////////////////////////////////

SVN address of this document source is: +
$HeadURL$

SVN date:
$LastChangedDate$

:numbered:

Introduction
------------

These modelling tools include two separate modules: *BASE_UTILS* and *CSV_IO*.
BASE_UTILS contains a few utility functions. CSV_IO is for output of numerical
data into the CSV (comma separated values) format files. CSV is good because it
is human-readable but can still be easily imported into spreadsheets and stats
packages.

Invoking the modules requires the _use_ keyword in Fortran. _use_' should
normally be the first statements before +implicit none+:


[source]
--------------------------------------------------------------------------------
program TEST

  use BASE_UTILS  ! Invoke the modules
  use CSV_IO      ! into this program

  implicit none

  character (len=255) :: REC
  integer :: i
  real, dimension(6) :: RARR = [0.1,0.2,0.3,0.4,0.5,0.6]
  character (len=4), dimension(6) :: STARR=["a1","a2","a3","a4","a5","a6"]

..........

end program TEST
--------------------------------------------------------------------------------

Building the program with these modules using the command line is notmally a
two-step process:

build the modules, e.g.

[source,bash]
--------------------------------------------------------------------------------
gfortran -g -c ../BASE_CSV_IO.f90 ../BASE_UTILS.f90
--------------------------------------------------------------------------------

This step should only be done if the source code of the modules change, i.e.
quite rarely.

build the program (e.g. TEST.f90) with these modules

[source,bash]
--------------------------------------------------------------------------------
gfortran -g -o TEST.exe TEST.f90 ../BASE_UTILS.f90 ../BASE_CSV_IO.f90
--------------------------------------------------------------------------------

or for a generic F95 compiler:

[source,bash]
--------------------------------------------------------------------------------
f95 -g -c ../BASE_CSV_IO.f90 ../BASE_UTILS.f90
f95 -g -o TEST.exe TEST.f90 ../BASE_UTILS.f90 ../BASE_CSV_IO.f90
--------------------------------------------------------------------------------

A static library of the modules could also be built, so the other more
changeable code can be just linked with the library.

Note: The examples above assume that the module code is located in the +
upper-level directory, so ../ , also the build script or Makefile should +
normally care about all this automatically.

Module: BASE_UTILS
------------------

indexterm:[BASE_UTILS]

This module contains a few utility functions and subroutines. So far there are
two useful things here: *STDOUT*, *STDERR*, *TOSTR*, *CLEANUP*, and
*RANDOM_SEED_INIT*.

Function: TOSTR
~~~~~~~~~~~~~~~

*TOSTR* converts everything to a string. Accepts any numeric or non-numeric
type, including integer and real (kind 4 and 8), logical and strings. Also
accepts arrays of these numeric types. Outputs just the string representation
of the number. Aliases: *STR* (same as *TOSTR*), *NUMTOSTR* (accepts only
numeric input parameter, not logical or string)

indexterm:[TOSTR]
indexterm:[STR]
indexterm:[NUMTOSTR]

Examples:
^^^^^^^^^

Integer:

[source]
--------------------------------------------------------------------------------
print *, TOSTR(12)
produces string "12"
--------------------------------------------------------------------------------

Single precision real (type 4)footnote:[Note that float point calculations,
especially single precision (real type 4) may introduce a rounding error]

[source]
--------------------------------------------------------------------------------
print *, ">>", TOSTR(3.1415926), "<<"
produces >>3.14159250<<
--------------------------------------------------------------------------------

Double precision real (type 8)

[source]
--------------------------------------------------------------------------------
print *, ">>", TOSTR(3.1415926_8), "<<"
produces >>3.1415926000000001<<
--------------------------------------------------------------------------------

TOSTR also converts logical type to the "TRUE" or "FALSE" strings and can also
accept character string as input. In the latest case it just output the input.

*Optional parameters*

TOSTR can also accept standard Fortran format string as the second optional
*string* parameter, for example:

[source]
--------------------------------------------------------------------------------
print *, ">>", TOSTR(3.1415926,"(f4.2)"), "<<"
produces >>3.14<<
--------------------------------------------------------------------------------

[source]
--------------------------------------------------------------------------------
print *, ">>", TOSTR(12,"(i4)"), "<<"
produces >>  12<<
--------------------------------------------------------------------------------

With integers, TOSTR can also generate leading zeros, which is useful for
auto-generating file names or variable names. In such cases, the number of
leading zeros is determined by the second optional *integer* parameter. This
integer sets the template for the leading zeros, the maximum string. The
exact value is unimportant, only the number of digits is used.

For example,

[source]
--------------------------------------------------------------------------------
print *, ">>", TOSTR(10, 100), "<<"
produces >>010<<
--------------------------------------------------------------------------------

[source]
--------------------------------------------------------------------------------
print *, ">>", TOSTR(10, 999), "<<"
also produces >>010<<
--------------------------------------------------------------------------------

[source]
--------------------------------------------------------------------------------
print *, "File_" // TOSTR(10, 10000) // ".txt"
produces File_00010.txt
--------------------------------------------------------------------------------

*Examples of arrays*

It is possible to convert numeric arrays to their string representation:

[source]
--------------------------------------------------------------------------------
real, dimension(6) :: RARR = [0.1,0.2,0.3,0.4,0.5,0.6]
.....
print *, ">>", TOSTR(RARR), "<<"
produces > 0.100000001 0.200000003 0.300000012 0.400000006 0.500000000 0.600000024<<
--------------------------------------------------------------------------------

Fortran format statement is also accepted for arrays:

[source]
--------------------------------------------------------------------------------
real, dimension(6) :: RARR = [0.1,0.2,0.3,0.4,0.5,0.6]
.....
print *, ">>", TOSTR(RARR,"(f4.2)"), "<<"
produces >> 0.10 0.20 0.30 0.40 0.50 0.60<<
--------------------------------------------------------------------------------

It is possible to use array slices and array constructors with implicit do:

indexterm:[implied do]
indexterm:[implied cycle]
indexterm:[array slice]

[source]
--------------------------------------------------------------------------------
print *, ">>", TOSTR(RARR(1:4)), "<<"
print *, ">>", TOSTR( (/(RARR(i), i=1,4)/) ), "<<"
both produce >> 0.100000001 0.200000003 0.300000012 0.400000006<<
--------------------------------------------------------------------------------

or using the newer format with square brackets:

[source]
--------------------------------------------------------------------------------
print *, ">>", TOSTR( [(RARR(i), i=1,4), 200.1, 400.5] ), "<<"
produces >> 0.100000001 0.200000003 0.300000012 0.400000006 200.100006 400.500000<<
--------------------------------------------------------------------------------

the same with format:

[source]
--------------------------------------------------------------------------------
print *, ">>", TOSTR( [(RARR(i), i=1,4), 200.1, 400.5], "(f9.3)" ), "<<"
produces >> 0.100 0.200 0.300 0.400 200.100 400.500<<
--------------------------------------------------------------------------------

The subroutine TOSTR is useful because it allows to change such confusing
old-style Fortran string constructions as this

[source]
--------------------------------------------------------------------------------
    !print new gene pool. First make file name      !BSA 18/11/13
        if (gen < 10) then
            write(gen1,2902) "gen-0000000",gen
          else if (gen < 100) then
            write(gen1,2903) "gen-0000000",gen
          else if (gen < 1000) then
            write(gen1,2904) "gen-000000",gen
          else if (gen < 10000) then
            write(gen1,2905) "gen-00000",gen
          else if (gen < 100000) then
            write(gen1,2906) "gen-0000",gen
          else if (gen < 1000000) then
            write(gen1,2907) "gen-000",gen
          else if (gen < 10000000) then
            write(gen1,2913) "gen-00",gen
          else if (gen < 100000000) then
            write(gen1,2914) "gen-0",gen
          else
            write(gen1,2915) "gen-",gen
   end if

   if (age < 10) then
            write(gen2,2920) "age-0000",age
          else if (age < 100) then
            write(gen2,2921) "age-000",age
          else if (age < 1000) then
            write(gen2,2922) "age-00",age
          else if (age < 10000) then
            write(gen2,2923) "age-0",age
          else
            write(gen2,2924) "age-",age
   end if

        write(gen3,2908)gen1,"-",gen2

        if (expmt < 10) then
            write(string104,2901)"HED24-",MMDD,runtag,"-E0",expmt,"-o104-genepool-",gen3,".txt"
          else
            write(string104,2910)"HED24-",MMDD,runtag,"-E",expmt,"-o104-genepool-",gen3,".txt"
        end if
--------------------------------------------------------------------------------

with much shorter and clear like this:

[source]
--------------------------------------------------------------------------------
    !print new gene pool. First make file name      !BSA 18/11/13
    string104 = "HED24-" // trim(MMDD) // trim(runtag) // "-E0" // &
                TOSTR(expmt,10) // "-o104-genepool-" // &
                "gen-" // TOSTR(gen, 10000000) //  "-" // &
                "age-" // TOSTR(age, 10000) // f_exten
--------------------------------------------------------------------------------

Subroutines: STDOUT and STDERR
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

These subroutines output arbitrary text to the terminal, either to the standard
output and standard error. While it seems trivial (standard Fortran print *, or
write() can be used), it is still good to have a dedicated standard subroutine
for all outputs as we can then easily modify the code to use Matlab/R API to
work with and run models from within these environments, or use a GUI window
(the least necessary feature now, but may be useful if the environment is used
for teaching in future). In such cases we will then implement a specific
dedicated output function and just globally swap STDOUT with something like
R_MESSAGE_PRINT or X_TXTGUI_PRINT.

indexterm:[STDOUT]
indexterm:[STDERR]

*STDOUT/STDERR* accept an arbitrary number of string parameters, which just
represent messages placed to the output. Each parameter is printed on a new
line. Trivial indeed:)

IMPORTANT: It is useful to have two separate subroutines for stdout and stderr
as they could be easily separated (e.g. redirected to different files).
Redirection could be done under Windows/Linux terminal in such a simple way: +
+model_command.exe 1>output_file_stdout 2>output_file_stderr+ +
Here STDOUT is redirected to output_file_stdout, STDERR, to output_file_stderr.

*Examples*

[source]
--------------------------------------------------------------------------------
call STDOUT("---------------------------------------------------",&
            ch01 // " = " // ch02 // TOSTR(inumber) // " ***", &
            ch10 // "; TEST NR= " // TOSTR(120.345), &
            "Pi equals to = " //  TOSTR(realPi, "(f4.2)"), &
            "---------------------------------------------------")
--------------------------------------------------------------------------------

The above code just prints a message. Note that TOSTR function is used to append
numerical values to the text output (unlike standard write where values are
separated by commas).


Function: CLEANUP
~~~~~~~~~~~~~~~~~

*CLEANUP* Removes all spaces, tabs, and any control characters from the input
string. It is useful to make sure there are no trailing spaces in fixed Fortran
strings and no spaces in file names.

indexterm:[CLEANUP]

Example:

[source]
--------------------------------------------------------------------------------
print *, ">>", CLEANUP("This is along string blablabla"), "<<"
produces >>Thisisalongstringblablabla<<
--------------------------------------------------------------------------------

Subroutine: RANDOM_SEED_INIT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
indexterm:[RANDOM_SEED_INIT]

*RANDOM_SEED_INIT* is called without parameters and just initialises the random
seed for the Fortran random number generator.

*Example*

[source]
--------------------------------------------------------------------------------
call RANDOM_SEED_INIT
--------------------------------------------------------------------------------

Module: CSV_IO
--------------

Overview
~~~~~~~~
indexterm:[CSV_IO]

This module contains subroutines and functions for outputting numerical data to
the http://en.wikipedia.org/wiki/Comma-separated_values[CSV (Comma Separated
Values)] format (http://tools.ietf.org/html/rfc4180/[RFC4180]).

The typical workflow for output in CSV file format is like this:
indexterm:[workflow]

** *CSV_OPEN_WRITE* - physically open CSV file for writing;
** *CSV_HEADER_WRITE* - physically write optional descriptive header (header
   is just the first line of the CSV file);
** do -- loop (1) over records (rows of data file) +
   do -- loop (2) over values within the same record +
    *CSV_RECORD_APPEND* - produce record of data values of different types,
    append single values, usually in a loop +
    end do -- end loop (2) +
    *CSV_RECORD_WRITE* - physically write the current record of data +
    to the output file.
** end do -- end loop(1) -- go to producing next record;
** end do -- end loop(2) -- cycle over the records;
** *CSV_CLOSE* - physically closes the output CSV file.

Thus, subs ending with *_WRITE* do physical write, as well as *_CLOSE*.

This module is most suited at this moment for CSV file _output_ rather than
input. Input CSV is to be done late if necessary.

This module widely uses optional arguments. They could be called irrespective
of the order using named parameters, e.g. this way (the first optional
parameter absent):
indexterm:[optional arguments]

[source]
intNextunit = GET_FREE_FUNIT(file_status=logicalFlag)

or (both parameters present but swapped in order):

[source]
intNextunit = GET_FREE_FUNIT(file_status=logicalFlag, max_funit=200)

or (optional parameters absent altogether):

[source]
intNextunit = GET_FREE_FUNIT()

or the standard way:

[source]
intNextunit = GET_FREE_FUNIT(200, logicalFlag)

Files can be referred either by unit or by name, but unit has  precedence (if
both a provided, unit is used). There is also a derived type *csv_file*
that can be used as a single file handle. If csv_file object is defined,
the file name, unit and the latest operation success status can be accessed
as +%name+, +%unit+, +%status+ (e.g. +some_file%name+, +some_file%unit+).

The physical file operation error flag, +csv_file_status+ is of logical type.
It is always an optional parameter.
indexterm:[optional arguments]

Here is an example of the data saving workflow:
indexterm:[workflow]

[source]
--------------------------------------------------------------------------------
use CSV_IO  ! invoke this module first
........
........
! 1. Generate file name for CSV output
csv_file_append_data_name="data_genomeNR_" // TOSTR(i) // "_" // TOSTR(j) // &
                          "_" // TOSTR(k) // ".csv"
........
! 2. open CSV file for writing
call CSV_OPEN_WRITE (csv_file_append_data_name, csv_file_append_data_unit, &
                     csv_written_ok)
if (.not. csv_written_ok) goto 1000 ! handle possible CSV error
! 3. Write optional descriptive header for the file
call CSV_HEADER_WRITE(csv_file_name = csv_file_append_data_name, &
                      header = header_is_from_this_string, &
                      csv_file_status = csv_written_ok)
........
! 4. Generate a whole record of variable names for the header
record_csv="" ! but first, prepare empty record string
call CSV_RECORD_APPEND(record_csv,["VAR_001", ("VAR_" // TOSTR(i,100),i=2,Cdip)])
........
! 5. Now we can write records containing actual data values, we do this
!    in two do-cycles
CYCLE_OVER_RECORDS: do l=1, Cdip
  ! 6. Prepare an empty string for the current CSV record
  record_csv=""
  CYCLE_WITHIN_RECORD: do m=1, CNRcomp
    ....
    ! do some calculations...
    .....
    ! 7. append the next value (single number) to the current record
    call CSV_RECORD_APPEND ( record_csv, genomeNR(l,m) )
    .....
  end do CYCLE_WITHIN_RECORD
  ! 8. physically write the current record
  call CSV_RECORD_WRITE ( record=record_csv, &
                          csv_file_name=csv_file_append_data_name,&
                          csv_file_status=csv_written_ok )
  if (.not. csv_written_ok) goto 1000 ! handle possible CSV error
  .......
end do CYCLE_OVER_RECORDS
! 9. close the CSV file when done
call CSV_CLOSE( csv_file_name=csv_file_append_data_name, &
                csv_file_status=csv_written_ok )
if (.not. csv_written_ok) goto 1000 ! handle possible CSV error
--------------------------------------------------------------------------------

Although, there are several wrappers for the most typical cases that can shorten
this procedure and write specific chunks of the data in fewer steps. For
example, a whole array or matrix (2-dimensional table) can be exported to CSV
in a single command:

[source]
--------------------------------------------------------------------------------
! save the whole matrix/array d_matrix to some_file.csv
call CSV_MATRIX_WRITE(d_matrix, "some_file.csv", fstat_csv)
if (.not. fstat_csv) goto 1000
--------------------------------------------------------------------------------

Subroutine: CSV_OPEN_WRITE
~~~~~~~~~~~~~~~~~~~~~~~~~
indexterm:[CSV_OPEN_WRITE]

Open CSV file for writing. May have two forms:

*(1)* either get three parameters:

[source]
--------------------------------------------------------------------------------
character (len=*) :: csv_file_name  ! file name
integer :: csv_file_unit            ! file unit
logical :: csv_file_status          ! optional status flag, TRUE if operation
                                    !   successful
--------------------------------------------------------------------------------

*(2)* get the (single) file handle object of the derived type +csv_file+

[source]
--------------------------------------------------------------------------------
type(csv_file), intent(inout) :: csv_file_handle  ! file handle object
--------------------------------------------------------------------------------

*Example*

[source]
--------------------------------------------------------------------------------
type(csv_file) :: file_occ      ! declare file handle object
........
call CSV_OPEN_WRITE(file_occ)   ! use file handle object
--------------------------------------------------------------------------------

Subroutine: CSV_CLOSE
~~~~~~~~~~~~~~~~~~~~
indexterm:[CSV_CLOSE]

Closes a CSV file for reading or writing. May have two forms:

*(1)* either get three optional parameters:

[source]
--------------------------------------------------------------------------------
character (len=*) :: csv_file_name  ! file name
integer :: csv_file_unit            ! file unit
logical :: csv_file_status          ! optional status flag, TRUE if operation
                                    !   successful
--------------------------------------------------------------------------------

IMPORTANT: At least *file name* or *unit* should be present in the subroutine
           call.


*(2)*  get one file handle object of the derived type +csv_file+

[source]
--------------------------------------------------------------------------------
type(csv_file), intent(inout) :: csv_file_handle  ! file handle object
--------------------------------------------------------------------------------

*Example*

[source]
--------------------------------------------------------------------------------
type(csv_file) :: file_occ      ! declare file handle object
........
call CSV_CLOSE(file_occ)        ! use file handle object
--------------------------------------------------------------------------------

Subroutine: CSV_HEADER_WRITE
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
indexterm:[CSV_HEADER_WRITE]

Writes an optional descriptive header to a CSV file. The header should normally
be the first line of the file.

May have two forms:

*(1)* either get four parameters, only the header is mandatory, but the file
      must be identified by name or unit:

[source]
--------------------------------------------------------------------------------
character (len=*) :: csv_file_name  ! file name
integer :: csv_file_unit            ! file unit
character (len=*) :: header         ! header string
logical :: csv_file_status          ! status flag, TRUE if operation successful
--------------------------------------------------------------------------------

IMPORTANT: At least *file name* or *unit* should be present in the subroutine
           call.

*(2)* get two parameters including the header string and the file handle object
      of the type +csv_file+

[source]
--------------------------------------------------------------------------------
character (len=*) :: header         ! mandatory CSV file header
type(csv_file) :: csv_file_handle   ! file handle object
--------------------------------------------------------------------------------

*Example*

[source]
--------------------------------------------------------------------------------
call CSV_HEADER_WRITE(csv_file_name=FILE_NAME_CSV1, &
      header="Example header. Total " // TOSTR(CSV_RECORD_SIZE(record_csv)) // &
      " columns of data.", csv_file_status=fstat_csv)
if (.not. fstat_csv) goto 1000
--------------------------------------------------------------------------------

Here CSV file header is generated from several components, including the
+CSV_RECORD_SIZE+ function to count the record size.


Function: GET_FILE_UNIT
~~~~~~~~~~~~~~~~~~~~~~~
indexterm:[GET_FILE_UNIT]

Returns file unit associated with an existing open file name, if no file unit
is associated with this name (file is not opened), return unit=-1 and error
status

Input parameters:

[source]
--------------------------------------------------------------------------------
character (len=*) :: csv_file_name    ! mandatory file name
logical :: csv_file_status            ! OPTIONAL status flag, TRUE if operation
                                      !   successful
--------------------------------------------------------------------------------

Output parameter (function value):

[source]
--------------------------------------------------------------------------------
integer :: csv_file_unit              ! unit associated with open file name
--------------------------------------------------------------------------------

*Example*

[source]
--------------------------------------------------------------------------------
file_unit = GET_FILE_UNIT(file_name)
--------------------------------------------------------------------------------

Function: GET_FREE_FUNIT
~~~~~~~~~~~~~~~~~~~~~~~~
indexterm:[GET_FREE_FUNIT]

Returns the next free/available Fortran file unit number. Can optionally search
until a specific maximum unit number.

Input parameters, optional:

[source]
--------------------------------------------------------------------------------
logical :: file_status                ! operation success status
integer :: max_funit                  ! maximum unit to search
--------------------------------------------------------------------------------

Output parameter (function value):

[source]
--------------------------------------------------------------------------------
integer :: file_unit                  ! the first free/available file unit
--------------------------------------------------------------------------------

IMPORTANT: When optional input parameters are absent, the function uses a
           hardwired maximum unit number, possibly depending on the computer
           platform and compiler used.

*Example*

[source]
--------------------------------------------------------------------------------
restart_file_unit_27 = GET_FREE_FUNIT()
--------------------------------------------------------------------------------

Function: CHECK_UNIT_VALID
~~~~~~~~~~~~~~~~~~~~~~~~~~
indexterm:[CHECK_UNIT_VALID]

Checks if file unit is valid, that is within the allowed range and doesn't
include standard input/output/stderr units. The unit should not necessarily
be linked to any file or be an open file.

Input parameter:

[source]
--------------------------------------------------------------------------------
integer :: file_unit                  ! Fortran file unit to check
--------------------------------------------------------------------------------

Output parameter (function value):
[source]
--------------------------------------------------------------------------------
logical :: file_status                ! gets TRUE if the unit is valid
--------------------------------------------------------------------------------

*Example*

[source]
--------------------------------------------------------------------------------
if (.not. CHECK_UNIT_VALID(csv_file_unit)) then
      csv_file_unit=GET_FREE_FUNIT(csv_file_status, MAX_UNIT)
.........
--------------------------------------------------------------------------------

In this example, we check if the user provided unit is valid, if not, get the
first available one.

Subroutine: CSV_RECORD_APPEND
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
indexterm:[CSV_RECORD_APPEND]

Appends one of the possible data objects to the current CSV record. Data objects
could be either a single value (integer, real with single or double
precision, character string) or a one-dimensional array of the above
types or still an arbitrary length list of the same data types from the above
list.

The first parameter of the subroutine is always character string record:

[source]
--------------------------------------------------------------------------------
character (len=*) :: record           ! character string record to append data
--------------------------------------------------------------------------------

The other parameters may be of any of thee following types: +integer (kind=4)+,
+real(kind=4)+, +real(kind=8)+, +character+ string.

IMPORTANT: The record keeping variable can be either fixed length string or an
allocatable string. But it should fit the whole record. This might be a little
bit tricky if record  is allocatable as +record_string=""+ it allocate it to an
empty string. A good tip is to use the +repeat+ function in Fortran to allocate
the record string to the necessary value, e.g. +record=repeat(" ", MAX_RECORD)+
will produce a string consisting of +MAX_RECORD+ blank characters. +record+
should not necessarily be an empty string initially, it could be just a whole
blank string.

Examples
^^^^^^^^

Append a single string to the current record:

[source]
--------------------------------------------------------------------------------
call CSV_RECORD_APPEND(record_csv, "ROW_NAMES")
--------------------------------------------------------------------------------

Append a single value (any of the supported types) to the current record:

[source]
--------------------------------------------------------------------------------
call CSV_RECORD_APPEND(record_csv, value)     ! some variable
call CSV_RECORD_APPEND(record_csv, 123.5_8)   ! double precision literal value
--------------------------------------------------------------------------------

Append a list of values (any one of the supported types) to the current record:

[source]
--------------------------------------------------------------------------------
call CSV_RECORD_APPEND(record_csv, fish, age, stat4, fecund)
--------------------------------------------------------------------------------

Append an array slice (any of the supported types) to the current record:

[source]
--------------------------------------------------------------------------------
call CSV_RECORD_APPEND(record_csv, RARR(1:4))
--------------------------------------------------------------------------------

indexterm:[array slice]

Append an array using old-style array constructor with implied do
(any of the supported types) to the current record:

[source]
--------------------------------------------------------------------------------
call CSV_RECORD_APPEND(record_csv,(/(RARR(i), i=1,6)/))
--------------------------------------------------------------------------------

indexterm:[implied do]
indexterm:[implied cycle]

Append an array using new-style array constructor (square brackets) with
implied do plus two other values (all values can have any of the supported
types but should have the same type) to the current record:

[source]
--------------------------------------------------------------------------------
call CSV_RECORD_APPEND(record_csv, [(RARR(i), i=1,4), measur1, age(fish)])
--------------------------------------------------------------------------------

Append integers from 1 to 10 to the current record (using implied do):

[source]
--------------------------------------------------------------------------------
call CSV_RECORD_APPEND(record_csv, [(i,i=1,10)])
--------------------------------------------------------------------------------

Append a string, an array of strings with implied do and finally another string
to the record. This example shows how variable (column) names could be
generated:

[source]
--------------------------------------------------------------------------------
call CSV_RECORD_APPEND(record_csv,["ROW_NAME",("VAR_" // TOSTR(i,1000),i=1,1000),"STATUS"])
--------------------------------------------------------------------------------

Function: CSV_RECORD_SIZE
~~~~~~~~~~~~~~~~~~~~~~~~~
indexterm:[CSV_RECORD_SIZE]

Counts the number of values in a CSV record.

Input parameters:

[source]
--------------------------------------------------------------------------------
character (len=*) :: record           ! mandatory CSV record
--------------------------------------------------------------------------------

Function value: an integer

--------------------------------------------------------------------------------
integer :: csv_record_size
--------------------------------------------------------------------------------

*Example*

[source]
--------------------------------------------------------------------------------
print *, "This record is: ", CSV_RECORD_SIZE(record_csv), " columns."
--------------------------------------------------------------------------------

Subroutine: CSV_RECORD_WRITE
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
indexterm:[CSV_RECORD_WRITE]

Physically writes a complete record of data to a CSV file. A record is a
single row of data in the file.
indexterm:[record]

This subroutine has two forms:

*(1)* it can either accept three parameters:

[source]
--------------------------------------------------------------------------------
character (len=*) :: csv_file_name        ! file name
integer :: csv_file_unit                  ! file unit
character (len=*)  :: record              ! current CSV record (mandatory)
logical :: csv_file_status                ! optional operation status, TRUE if
                                          !  success
--------------------------------------------------------------------------------

IMPORTANT: The file to write the current record can be referred either by
           name or unit. So one of them must be present in the subroutine call.

*(2)* get the CSV record and the (single) file handle object of the derived
      type +csv_file+

[source]
--------------------------------------------------------------------------------
character (len=*)  :: record              ! current CSV record (mandatory)
type(csv_file) :: csv_file_handle         ! file handle object
--------------------------------------------------------------------------------

*Example*

[source]
--------------------------------------------------------------------------------
call CSV_RECORD_WRITE(csv_record, file_cop)               ! write current record
call LOG_MSG("Physically wrote record " // TOSTR(a) // &  ! report this in some
             " to the file " // file_cop%name // &        ! logging subroutine.
             ", write status =" // TOSTR(file_cop%status))
--------------------------------------------------------------------------------

Note, that file handle object is used in the above example.

Subroutine: CSV_MATRIX_WRITE
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
indexterm:[CSV_MATRIX_WRITE]
indexterm:[CSV_ARRAY_WRITE]

Writes a matrix of real (kind 4 or  8), integer or string values to a CSV data
file. This is a shortcut allowing to write data ina single code instruction.

It gets three parameters: one-dimensional array or two-dimensional data matrix
(of any supported type), string file name and an optional logical file
operation status.

[source]
--------------------------------------------------------------------------------
integer, dimension(:,:) :: matrix     ! data object, array or 2-d matrix
character (len=*) :: csv_file_name    ! file name for output
logical :: csv_file_status            ! operation status, TRUE if success
--------------------------------------------------------------------------------

There is also an alias to this subroutine, +CSV_ARRAY_WRITE+, which is for
output of one-dimensional array to CSV.

IMPORTANT: Note, that one-dimensional array is written to the file as a single
           row, not as a column.

*Example*

[source]
--------------------------------------------------------------------------------
call CSV_MATRIX_WRITE (ARRAY_Z, "test-file-001.csv", fstat_csv)
 if (.not. fstat_csv) goto 1000
--------------------------------------------------------------------------------





Final Notes
-----------

There are a few other modules. I will write similar documentation for them
too... Hope it is soon. There is still much to to.

The manual is generated with http://asciidoc.org/[AsciiDoc] markup processor. Later,
an auto-generation of docs from the model code is planned (not first priority
though).

